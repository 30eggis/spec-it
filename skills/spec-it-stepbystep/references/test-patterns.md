# Test Patterns Guide

Pattern guide for test specifications generated by spec-it.

## Coverage Goals (spec-it-execute Target)

> **중요:** spec-it-execute Phase 6에서 95% 커버리지 목표 달성이 필요합니다.

| Type | Minimum | Recommended | spec-it-execute Target |
|------|---------|-------------|------------------------|
| Unit | 70% | 90% | **95%** |
| Integration | 50% | 70% | 80% |
| E2E | 30% | 50% | 100% (모든 시나리오 통과) |
| A11y | 100% | 100% | 100% |

### 커버리지 우선순위

1. **P0 컴포넌트:** 100% 커버리지 필수
2. **Critical Path 함수:** 100% 커버리지 필수
3. **P1 컴포넌트:** 90% 이상
4. **P2 컴포넌트:** 80% 이상

## Test Types

### 1. Unit Tests

Testing independent behavior of individual components/functions

```typescript
// Component Unit Test
describe('Button', () => {
  it('renders with default props', () => {
    render(<Button>Click me</Button>);
    expect(screen.getByRole('button')).toHaveTextContent('Click me');
  });

  it('calls onClick when clicked', async () => {
    const handleClick = vi.fn();
    render(<Button onClick={handleClick}>Click</Button>);
    await userEvent.click(screen.getByRole('button'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  it('is disabled when disabled prop is true', () => {
    render(<Button disabled>Disabled</Button>);
    expect(screen.getByRole('button')).toBeDisabled();
  });
});
```

### 2. Integration Tests

Testing scenarios where multiple components work together

```typescript
// Form Integration Test
describe('LoginForm', () => {
  it('submits form with valid data', async () => {
    const handleSubmit = vi.fn();
    render(<LoginForm onSubmit={handleSubmit} />);

    await userEvent.type(screen.getByLabelText('Email'), 'test@example.com');
    await userEvent.type(screen.getByLabelText('Password'), 'password123');
    await userEvent.click(screen.getByRole('button', { name: 'Login' }));

    expect(handleSubmit).toHaveBeenCalledWith({
      email: 'test@example.com',
      password: 'password123',
    });
  });

  it('shows validation errors', async () => {
    render(<LoginForm onSubmit={vi.fn()} />);

    await userEvent.click(screen.getByRole('button', { name: 'Login' }));

    expect(screen.getByText('Email is required')).toBeInTheDocument();
    expect(screen.getByText('Password is required')).toBeInTheDocument();
  });
});
```

### 3. E2E Tests (Playwright)

Testing complete user flows

```typescript
// E2E Test
test('user can login and access dashboard', async ({ page }) => {
  // Given
  await page.goto('/login');

  // When
  await page.fill('[data-testid="email"]', 'user@example.com');
  await page.fill('[data-testid="password"]', 'password123');
  await page.click('[data-testid="login-button"]');

  // Then
  await expect(page).toHaveURL('/dashboard');
  await expect(page.locator('[data-testid="welcome-message"]')).toContainText('Welcome');
});
```

## Test Patterns

### AAA Pattern (Arrange-Act-Assert)

```typescript
it('should do something', () => {
  // Arrange - Setup
  const input = 'test input';
  const expected = 'expected output';

  // Act - Execute
  const result = functionUnderTest(input);

  // Assert - Verify
  expect(result).toBe(expected);
});
```

### Given-When-Then Pattern

```typescript
it('should update state when button clicked', () => {
  // Given - Precondition
  const { getByRole } = render(<Counter initialCount={0} />);

  // When - Action
  fireEvent.click(getByRole('button', { name: 'Increment' }));

  // Then - Expected result
  expect(getByRole('heading')).toHaveTextContent('Count: 1');
});
```

## Component Test Checklist

### Rendering
- [ ] Renders with default props
- [ ] Error on missing required props
- [ ] Optional props behavior
- [ ] Children rendering

### States
- [ ] default state
- [ ] hover state
- [ ] focus state
- [ ] disabled state
- [ ] loading state
- [ ] error state

### Interactions
- [ ] Click events
- [ ] Keyboard events
- [ ] Form submission
- [ ] Input changes

### Accessibility
- [ ] aria attributes
- [ ] Keyboard navigation
- [ ] Screen reader compatibility
- [ ] Focus management

## Test Quality Review Criteria

> **spec-it-execute Phase 6에서 test-critic Agent가 검사하는 항목**

### 의미 없는 테스트 탐지

```typescript
// BAD: 항상 통과하는 테스트
it('should exist', () => {
  expect(true).toBe(true);
});

// BAD: assertion 없음
it('should render', () => {
  render(<Component />);
  // assertion 없음!
});

// GOOD: 의미 있는 assertion
it('should render title', () => {
  render(<Component title="Hello" />);
  expect(screen.getByText('Hello')).toBeInTheDocument();
});
```

### Edge Case 검증

```typescript
// 반드시 테스트해야 할 Edge Cases
describe('PriceDisplay', () => {
  // Boundary values
  it('handles zero price', () => {...});
  it('handles negative price', () => {...});
  it('handles very large numbers', () => {...});

  // Invalid inputs
  it('handles undefined price', () => {...});
  it('handles NaN price', () => {...});

  // Special formats
  it('handles decimal precision', () => {...});
  it('handles currency symbols', () => {...});
});
```

### Mock 남용 방지

```typescript
// BAD: 모든 것을 mock (실제 동작 테스트 안됨)
it('should fetch data', async () => {
  vi.mock('./api', () => ({ fetchData: vi.fn().mockResolvedValue([]) }));
  // 실제 fetch 로직 테스트 안됨
});

// GOOD: MSW로 API mock, 실제 컴포넌트 동작 테스트
it('should display fetched data', async () => {
  server.use(
    rest.get('/api/data', (req, res, ctx) => {
      return res(ctx.json([{ id: 1, name: 'Item' }]));
    })
  );
  render(<DataList />);
  await waitFor(() => {
    expect(screen.getByText('Item')).toBeInTheDocument();
  });
});
```

### 테스트 격리 검증

```typescript
// BAD: 테스트 간 상태 공유
let sharedState = [];
beforeEach(() => {
  sharedState.push('item'); // 테스트마다 누적!
});

// GOOD: 각 테스트 독립적
beforeEach(() => {
  // 완전 초기화
  cleanup();
  vi.clearAllMocks();
});
```

### Flaky Test 탐지

```typescript
// BAD: 타이밍 의존 (불안정)
it('shows loading then data', async () => {
  render(<AsyncComponent />);
  expect(screen.getByText('Loading')).toBeInTheDocument();
  await new Promise(r => setTimeout(r, 1000)); // 위험!
  expect(screen.getByText('Data')).toBeInTheDocument();
});

// GOOD: waitFor 사용 (안정적)
it('shows loading then data', async () => {
  render(<AsyncComponent />);
  expect(screen.getByText('Loading')).toBeInTheDocument();
  await waitFor(() => {
    expect(screen.getByText('Data')).toBeInTheDocument();
  });
});
```

## Mocking Patterns

### API Mock

```typescript
// MSW (Mock Service Worker)
import { rest } from 'msw';
import { setupServer } from 'msw/node';

const server = setupServer(
  rest.get('/api/user', (req, res, ctx) => {
    return res(ctx.json({ name: 'John' }));
  })
);

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());
```

### Module Mock

```typescript
// vi.mock
vi.mock('@/lib/api', () => ({
  fetchUser: vi.fn().mockResolvedValue({ name: 'John' }),
}));
```

### Timer Mock

```typescript
beforeEach(() => {
  vi.useFakeTimers();
});

afterEach(() => {
  vi.useRealTimers();
});

it('debounces input', async () => {
  render(<SearchInput />);
  await userEvent.type(screen.getByRole('textbox'), 'test');
  vi.advanceTimersByTime(300);
  // assertions
});
```

## Persona-Based Testing

```typescript
// Persona: Busy Professional
describe('Busy Professional Scenario', () => {
  const persona = {
    device: 'mobile',
    connection: 'slow-3g',
    timeConstraint: 'limited',
  };

  it('accesses core info within 3 seconds', async ({ page }) => {
    await page.emulateNetworkConditions(slow3G);
    const start = Date.now();

    await page.goto('/dashboard');
    await page.waitForSelector('[data-testid="key-metric"]');

    expect(Date.now() - start).toBeLessThan(3000);
  });

  it('performs main functions with one hand', async ({ page }) => {
    await page.setViewportSize({ width: 375, height: 667 });

    // All main buttons should be in bottom 1/3 of screen
    const buttons = await page.locator('[data-testid="action-button"]').all();
    for (const button of buttons) {
      const box = await button.boundingBox();
      expect(box.y).toBeGreaterThan(667 * 0.66);
    }
  });
});
```

## Test Naming Convention

```
[Target] [Condition] [Expected Result]

Examples:
- Button renders correctly with default props
- Form shows validation error when email is invalid
- User can navigate to dashboard after login
```

## Test File Organization

```
src/
├── components/
│   ├── Button/
│   │   ├── Button.tsx
│   │   ├── Button.test.tsx      # Unit tests
│   │   └── Button.stories.tsx   # Storybook (optional)
│   └── ...
├── features/
│   ├── auth/
│   │   ├── LoginForm.tsx
│   │   └── LoginForm.test.tsx
│   └── ...
└── __tests__/
    └── integration/              # Integration tests
        └── login-flow.test.tsx

e2e/
├── critical-path.spec.ts         # Critical path E2E
├── dashboard.spec.ts             # Screen-based E2E
└── ...
```

## Reference Tools

- **Vitest**: Test runner
- **React Testing Library**: Component testing
- **Playwright**: E2E testing
- **MSW**: API mocking
- **axe-core**: Accessibility testing

## spec-test-loader Integration

테스트 스펙을 점진적으로 로딩하여 컨텍스트 효율성을 높입니다:

```
# 전체 테스트 목록 확인
/spec-test-loader {spec-folder} --list

# 우선순위별 로딩
/spec-test-loader {spec-folder} --priority P0
/spec-test-loader {spec-folder} --priority P1

# 커버리지 갭 분석
/spec-test-loader {spec-folder} --coverage-gap

# 특정 컴포넌트 테스트
/spec-test-loader {spec-folder} --component StockCard
```
